// SPDX-License-Identifier: GPL-2.0-or-later
/** @file
 * A C++ wrapper for lcms2 profiles
 *//*
 * Authors: see git history
 *
 * Copyright (C) 2018 Authors
 * Released under GNU GPL v2+, read the file 'COPYING' for more information.
 */

#include "profile.h"

#include <codecvt>
#include <fcntl.h>
#include <glib/gstdio.h>
#include <glibmm.h>
#include <glibmm/checksum.h>
#include <iomanip>
#include <map>
#include <sstream>
#include <unistd.h>

#include "util-string/string-convert.h"

namespace Inkscape::Colors::CMS {

/**
 * Wrapper for lcms2 profile tag writing.
 */
bool _cmsWriteTag(cmsHPROFILE hProfile, cmsTagSignature tag, std::string const &value)
{
    bool result = false;
    auto ContextID = cmsGetProfileContextID(hProfile);
    if (auto mlu = cmsMLUalloc(ContextID, 1)) {
        std::wstring wide_string = utf8_to_wstring(value);
        if (cmsMLUsetWide(mlu,  "en", "US", wide_string.c_str())) {
            result = cmsWriteTag(hProfile, tag,  mlu);
        }
        cmsMLUfree(mlu);
    }
    return result;
}

/**
 * Construct a color profile object from the lcms2 object.
 */
std::shared_ptr<Profile> Profile::create(cmsHPROFILE handle, std::string path, bool in_home)
{
    return handle ? std::make_shared<Profile>(handle, std::move(path), in_home) : nullptr;
}

/**
 * Copy the cmsHPROFILE object before creating a Profile
 */
std::shared_ptr<Profile> Profile::create_from_copy(cmsHPROFILE handle)
{
    auto data = dumpData(handle);
    if (cmsHPROFILE profile = cmsOpenProfileFromMem(data.data(), data.size())) {
        return Profile::create(profile, "", false);
    }
    return nullptr;
}

/**
 * Construct a color profile object from a uri. Ownership of the lcms2 object is contained
 * within the Profile object and will be destroyed when it is.
 */
std::shared_ptr<Profile> Profile::create_from_uri(std::string path, bool in_home)
{
    if (cmsHPROFILE profile = cmsOpenProfileFromFile(path.c_str(), "r"))
        return Profile::create(profile, std::move(path), in_home);
    return nullptr;
}

/**
 * Construct a color profile object from the raw data.
 */
std::shared_ptr<Profile> Profile::create_from_data(std::string const &contents)
{
    if (cmsHPROFILE profile = cmsOpenProfileFromMem(contents.data(), contents.size()))
        return Profile::create(profile, "", false);
    return nullptr;
}

/**
 * Construct the default lcms sRGB color profile and return.
 */
std::shared_ptr<Profile> Profile::create_srgb()
{
    return Profile::create(cmsCreate_sRGBProfile());
}

/**
 * Construct a linear light sRGB,, D65 coolor profile and return.
 */
std::shared_ptr<Profile> Profile::create_linearrgb()
{
    cmsCIExyY D65;
    cmsWhitePointFromTemp(&D65, 6504);
    cmsCIExyYTRIPLE Rec709Primaries = {
      {0.639998686, 0.330010138, 1.0}, // Red: xyY
      {0.300003784, 0.600003357, 1.0}, // Green: xyY
      {0.150002046, 0.059997204, 1.0}  // Blue: xyY
    };
    cmsToneCurve *linear[3];
    linear[0] = cmsBuildGamma(NULL, 1);
    linear[1] = cmsBuildGamma(NULL, 1);
    linear[2] = cmsBuildGamma(NULL, 1);
    auto hProfile = cmsCreateRGBProfile(&D65, &Rec709Primaries, linear);
    _cmsWriteTag(hProfile, cmsSigProfileDescriptionTag, "linearRGB identity with D65");
    cmsFreeToneCurve(linear[0]);
    cmsFreeToneCurve(linear[1]);
    cmsFreeToneCurve(linear[2]);
    return Profile::create(hProfile);
}

/**
 * Construct a LAB D50 color profile for CSS Color Module 4
 */
std::shared_ptr<Profile> Profile::create_lab()
{
    // nullptr means D50
    return Profile::create(cmsCreateLab2Profile(nullptr));
}

/**
 * Create a standard CIE XYZ D65 lcms2 profile and return.
 */
std::shared_ptr<Profile> Profile::create_xyz65()
{
    // A static icc indentity for D65 xyz. It's not possible to construct this via lcms XYZ identity functions.
    static const unsigned char d65_xyz[] = {0x0,0x0,0x3,0xc8,0x6e,0x6f,0x6e,0x65,0x2,0x40,0x0,0x0,0x6d,0x6e,0x74,0x72,0x52,0x47,0x42,0x20,0x58,0x59,0x5a,0x20,0x7,0xd4,0x0,0x7,0x0,0x15,0x0,0x12,0x0,0x39,0x0,0x2a,0x61,0x63,0x73,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6e,0x6f,0x6e,0x65,0x6e,0x6f,0x6e,0x65,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0xf6,0xd6,0x0,0x1,0x0,0x0,0x0,0x0,0xd3,0x2d,0x6e,0x6f,0x6e,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x64,0x65,0x73,0x63,0x0,0x0,0x1,0x44,0x0,0x0,0x0,0x6a,0x62,0x58,0x59,0x5a,0x0,0x0,0x1,0xb0,0x0,0x0,0x0,0x14,0x62,0x54,0x52,0x43,0x0,0x0,0x1,0xc4,0x0,0x0,0x0,0xc,0x64,0x6d,0x64,0x64,0x0,0x0,0x1,0xd0,0x0,0x0,0x0,0x88,0x67,0x58,0x59,0x5a,0x0,0x0,0x2,0x58,0x0,0x0,0x0,0x14,0x67,0x54,0x52,0x43,0x0,0x0,0x1,0xc4,0x0,0x0,0x0,0xc,0x6c,0x75,0x6d,0x69,0x0,0x0,0x2,0x6c,0x0,0x0,0x0,0x14,0x6d,0x65,0x61,0x73,0x0,0x0,0x2,0x80,0x0,0x0,0x0,0x24,0x62,0x6b,0x70,0x74,0x0,0x0,0x2,0xa4,0x0,0x0,0x0,0x14,0x72,0x58,0x59,0x5a,0x0,0x0,0x2,0xb8,0x0,0x0,0x0,0x14,0x72,0x54,0x52,0x43,0x0,0x0,0x1,0xc4,0x0,0x0,0x0,0xc,0x74,0x65,0x63,0x68,0x0,0x0,0x2,0xcc,0x0,0x0,0x0,0xc,0x76,0x75,0x65,0x64,0x0,0x0,0x2,0xd8,0x0,0x0,0x0,0x87,0x77,0x74,0x70,0x74,0x0,0x0,0x3,0x60,0x0,0x0,0x0,0x14,0x63,0x70,0x72,0x74,0x0,0x0,0x3,0x74,0x0,0x0,0x0,0x28,0x63,0x68,0x61,0x64,0x0,0x0,0x3,0x9c,0x0,0x0,0x0,0x2c,0x64,0x65,0x73,0x63,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x44,0x36,0x35,0x20,0x58,0x59,0x5a,0x20,0x70,0x72,0x6f,0x66,0x69,0x6c,0x65,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58,0x59,0x5a,0x20,0x0,0x0,0x0,0x0,0xff,0xff,0xf3,0x26,0xff,0xff,0xfb,0xa1,0x0,0x0,0xc0,0x75,0x63,0x75,0x72,0x76,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x64,0x65,0x73,0x63,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2e,0x49,0x45,0x43,0x20,0x36,0x31,0x39,0x36,0x36,0x2d,0x32,0x2d,0x31,0x20,0x44,0x65,0x66,0x61,0x75,0x6c,0x74,0x20,0x52,0x47,0x42,0x20,0x43,0x6f,0x6c,0x6f,0x75,0x72,0x20,0x53,0x70,0x61,0x63,0x65,0x20,0x2d,0x20,0x73,0x52,0x47,0x42,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58,0x59,0x5a,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x5,0xdf,0x0,0x0,0xfd,0x8f,0x0,0x0,0x3,0xdb,0x58,0x59,0x5a,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x50,0x0,0x0,0x0,0x0,0x0,0x0,0x6d,0x65,0x61,0x73,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x58,0x59,0x5a,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x16,0x0,0x0,0x3,0x33,0x0,0x0,0x2,0xa4,0x58,0x59,0x5a,0x20,0x0,0x0,0x0,0x0,0x0,0x1,0xc,0x44,0x0,0x0,0x7,0x94,0xff,0xff,0xfd,0xa2,0x73,0x69,0x67,0x20,0x0,0x0,0x0,0x0,0x43,0x52,0x54,0x20,0x64,0x65,0x73,0x63,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2d,0x52,0x65,0x66,0x65,0x72,0x65,0x6e,0x63,0x65,0x20,0x56,0x69,0x65,0x77,0x69,0x6e,0x67,0x20,0x43,0x6f,0x6e,0x64,0x69,0x74,0x69,0x6f,0x6e,0x20,0x69,0x6e,0x20,0x49,0x45,0x43,0x20,0x36,0x31,0x39,0x36,0x36,0x2d,0x32,0x2d,0x31,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x58,0x59,0x5a,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0xf6,0xd6,0x0,0x1,0x0,0x0,0x0,0x0,0xd3,0x2d,0x74,0x65,0x78,0x74,0x0,0x0,0x0,0x0,0x43,0x6f,0x70,0x79,0x72,0x69,0x67,0x68,0x74,0x20,0x48,0x65,0x77,0x6c,0x65,0x74,0x74,0x20,0x50,0x61,0x63,0x6b,0x61,0x72,0x64,0x2c,0x20,0x32,0x30,0x30,0x34,0x0,0x73,0x66,0x33,0x32,0x0,0x0,0x0,0x0,0x0,0x1,0xc,0x44,0x0,0x0,0x5,0xdf,0xff,0xff,0xf3,0x26,0x0,0x0,0x7,0x94,0x0,0x0,0xfd,0x8f,0xff,0xff,0xfb,0xa1,0xff,0xff,0xfd,0xa2,0x0,0x0,0x3,0xdb,0x0,0x0,0xc0,0x75};
    return Profile::create(cmsOpenProfileFromMem(d65_xyz, sizeof(d65_xyz)), "", false);
}

/**
 * Create a standard CIE XYZ D50 lcms2 profile and return.
 */
std::shared_ptr<Profile> Profile::create_xyz50()
{
    return Profile::create(cmsCreateXYZProfile());
}

Profile::Profile(cmsHPROFILE handle, std::string path, bool in_home)
    : _handle(handle)
    , _path(std::move(path))
    , _id(generate_id())
    , _checksum(generate_checksum())
    , _in_home(in_home)
{
    assert(_handle);
}

/**
 * Return true if this profile is for display/monitor correction.
 */
bool Profile::isForDisplay() const
{
    // If the profile has a Video Card Gamma Table (VCGT), then it's very likely to
    // be an actual monitor/display icc profile, and not just a display RGB profile.
    return getProfileClass() == cmsSigDisplayClass && getColorSpace() == cmsSigRgbData &&
           cmsIsTag(_handle, cmsSigVcgtTag);
}

/**
 * Cleans up name to remove disallowed characters.
 *
 * Allowed ASCII first characters:  ':', 'A'-'Z', '_', 'a'-'z'
 * Allowed ASCII remaining chars add: '-', '.', '0'-'9',
 *
 * @param str the string to clean up.
 */
static void sanitize_name(std::string &str)
{
    if (str.empty())
        return;
    auto val = str[0];
    if ((val < 'A' || val > 'Z') && (val < 'a' || val > 'z') && val != '_' && val != ':') {
        str.insert(0, "_");
    }
    for (std::size_t i = 1; i < str.size(); i++) {
        auto val = str[i];
        if ((val < 'A' || val > 'Z') && (val < 'a' || val > 'z') && (val < '0' || val > '9') && val != '_' &&
            val != ':' && val != '-' && val != '.') {
            if (str.at(i - 1) == '-') {
                str.erase(i, 1);
                i--;
            } else {
                str[i] = '-';
            }
        }
    }
    if (str.back() == '-') {
        str.pop_back();
    }
}

/**
 * Returns the name inside the icc profile, or empty string if it couldn't be
 * parsed out of the icc data correctly.
 */
std::string Profile::getName(bool sanitize) const
{
    std::string name;
    cmsUInt32Number byteLen = cmsGetProfileInfo(_handle, cmsInfoDescription, "en", "US", nullptr, 0);
    if (byteLen > 0) {
        // allocate buffer at least byteLen bytes in size
        constexpr int wc = sizeof(wchar_t);
        std::vector<wchar_t> data((byteLen + wc - 1) / wc);
        // lcms returns nul-terminated wide string
        auto readLen = cmsGetProfileInfo(_handle, cmsInfoDescription, "en", "US", data.data(), byteLen);
        if (readLen < byteLen) {
            g_warning("Profile::get_name(): icc data read less than expected!");
        }
        name = wstring_to_utf8(data.data());
    }
    if (sanitize)
        sanitize_name(name);
    return name;
}

cmsColorSpaceSignature Profile::getColorSpace() const
{
    return cmsGetColorSpace(_handle);
}

cmsProfileClassSignature Profile::getProfileClass() const
{
    return cmsGetDeviceClass(_handle);
}

struct InputFormatMap
{
    cmsColorSpaceSignature space;
    cmsUInt32Number inForm;
};

/**
 * Returns the number of channels this profile stores for color information.
 */
unsigned int Profile::getSize() const
{
    switch (getColorSpace()) {
        case cmsSigGrayData:
            return 1;
        case cmsSigCmykData:
            return 4;
        default:
            return 3;
    }
}

bool Profile::isIccFile(std::string const &filepath)
{
    bool is_icc_file = false;
    GStatBuf st;
    if (g_stat(filepath.c_str(), &st) == 0 && st.st_size > 128) {
        // 0-3 == size
        // 36-39 == 'acsp' 0x61637370
        int fd = g_open(filepath.c_str(), O_RDONLY, S_IRWXU);
        if (fd != -1) {
            guchar scratch[40] = {0};
            size_t len = sizeof(scratch);

            ssize_t got = read(fd, scratch, len);
            if (got != -1) {
                size_t calcSize = (scratch[0] << 24) | (scratch[1] << 16) | (scratch[2] << 8) | (scratch[3]);
                if (calcSize > 128 && calcSize <= static_cast<size_t>(st.st_size)) {
                    is_icc_file =
                        (scratch[36] == 'a') && (scratch[37] == 'c') && (scratch[38] == 's') && (scratch[39] == 'p');
                }
            }
            close(fd);

            if (is_icc_file) {
                cmsHPROFILE profile = cmsOpenProfileFromFile(filepath.c_str(), "r");
                if (profile) {
                    cmsProfileClassSignature profClass = cmsGetDeviceClass(profile);
                    if (profClass == cmsSigNamedColorClass) {
                        is_icc_file = false; // Ignore named color profiles for now.
                    }
                    cmsCloseProfile(profile);
                }
            }
        }
    }
    return is_icc_file;
}

/**
 * Get the id from the cms header itself, ususally correct but sometimes will be
 * completely empty. Use generate_checksum to make a new one.
 */
std::string Profile::get_id() const
{
    cmsUInt8Number tmp[16];
    cmsGetHeaderProfileID(_handle, tmp);

    std::ostringstream oo;
    oo << std::hex << std::setfill('0');
    for (auto &digit : tmp) {
        // Setw must happen each loop
        oo << std::setw(2) << static_cast<unsigned>(digit);
    }
    return oo.str();
}

/**
 * Get or generate a profile Id, and save in the object for later use.
 */
std::string Profile::generate_id() const
{
    auto s = get_id();
    if (std::ranges::count(s, '0') < 24) {
        return s; // Done
    }
    // If there's no path, then what we have is a generated or in-memory profile
    // which is unlikely to ever need to be matched with anything via id but it's
    // also true that this id would change between computers, and creation date.
    if (_path.empty()) {
        return "";
    }
    return generate_checksum();
}

/**
 * Generate a checksum of the data according to the ICC specification
 */
std::string Profile::generate_checksum() const
{
    // 2. If the id is empty, for some reason, we're going to generate it
    // from the data using the same method that should have been used originally
    // See ICC.1-2022-05 7.2.18 Profile ID field.
    auto data = dumpData();
    if (data.size() < 100) {
        g_warning("Bad icc profile data when generating profile id.");
        return "~";
    }
    // Zero out the required bytes as per the above specification
    for (unsigned i = 44; i < 48; i++)
        data[i] = 0;
    for (unsigned i = 64; i < 68; i++)
        data[i] = 0;
    for (unsigned i = 84; i < 100; i++)
        data[i] = 0;
    return Glib::Checksum::compute_checksum(Glib::Checksum::Type::MD5, std::string(data.begin(), data.end()));
}

/**
 * Dump the entire profile as a base64 encoded string. This is used for color-profile href data.
 */
std::string Profile::dumpBase64() const
{
    auto buf = dumpData();
    return Glib::Base64::encode(std::string(buf.begin(), buf.end()));
}

/**
 * Dump the entire profile as raw data. Used in dumpBase64 and generateId
 */
std::vector<unsigned char> Profile::dumpData(cmsHPROFILE profile)
{
    cmsUInt32Number len = 0;
    if (!cmsSaveProfileToMem(profile, nullptr, &len)) {
        throw CmsProfileError("Can't extract profile data");
    }
    auto buf = std::vector<unsigned char>(len);
    cmsSaveProfileToMem(profile, &buf.front(), &len);
    return buf;
}

} // namespace Inkscape::Colors::CMS

/*
  Local Variables:
  mode:c++
  c-file-style:"stroustrup"
  c-file-offsets:((innamespace . 0)(inline-open . 0)(case-label . +))
  indent-tabs-mode:nil
  fill-column:99
  End:
*/
// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:fileencoding=utf-8:textwidth=99 :
