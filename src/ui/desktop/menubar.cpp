// SPDX-License-Identifier: GPL-2.0-or-later
/**
 * @file
 * Desktop main menu bar code.
 */
/*
 * Authors:
 *   Tavmjong Bah       <tavmjong@free.fr>
 *   Alex Valavanis     <valavanisalex@gmail.com>
 *   Patrick Storz      <eduard.braun2@gmx.de>
 *   Krzysztof Kosi≈Ñski <tweenk.pl@gmail.com>
 *   Kris De Gussem     <Kris.DeGussem@gmail.com>
 *   Sushant A.A.       <sushant.co19@gmail.com>
 *
 * Copyright (C) 2025 Authors
 *
 * The contents of this file may be used under the GNU General Public License Version 2 or later.
 * Read the file 'COPYING' for more information.
 */

#include "menubar.h"

#include <glibmm/regex.h>
#include <giomm/menu.h>
#include <giomm/menuattributeiter.h>
#include <giomm/menulinkiter.h>
#include <glibmm/i18n.h>
#include <gtkmm/builder.h>

#include "actions/actions-effect.h"
#include "inkscape-application.h"
#include "io/recent-files.h"
#include "io/resource.h" // UI File location
#include "preferences.h" // max recent documents

// Rebuild menu with icons enabled or disabled. Recursive.
static void rewrite_menu(Glib::RefPtr<Gio::Menu> const &menu, int use_icons);

void build_menu()
{
    auto const filename = Inkscape::IO::Resource::get_filename(Inkscape::IO::Resource::UIS, "menus.ui");
    auto const builder = Gtk::Builder::create();

    try {
        builder->add_from_file(filename);
    } catch (Glib::Error const &err) {
        std::cerr << "build_menu: failed to load Main menu from: "
                  << filename << ": "
                  << err.what() << std::endl;
        return;
    }

    auto const menu = builder->get_object<Gio::Menu>("menus");
    if (!menu) {
        std::cerr << "build_menu: failed to build Main menu!" << std::endl;
        return;
    }

    auto app = InkscapeApplication::instance();
    enable_effect_actions(app, false);
    auto &label_to_tooltip_map = app->get_menu_label_to_tooltip_map();
    label_to_tooltip_map.clear();

    { // Filters and Extensions
        auto const effects_menu = builder->get_object<Gio::Menu>("effect-menu-effects");
        auto const filters_menu = builder->get_object<Gio::Menu>("filter-menu-filters");
        if (!filters_menu) {
            std::cerr << "build_menu(): Couldn't find Filters menu entry!" << std::endl;
        }
        if (!effects_menu) {
            std::cerr << "build_menu(): Couldn't find Extensions menu entry!" << std::endl;
        }

        std::map<std::string, Glib::RefPtr<Gio::Menu>> submenus;

        for (auto const &entry : app->get_action_effect_data().give_all_data()) {
            auto const &submenu_name_list = entry.submenu;

            // Effect data is used for both filters menu and extensions menu... we need to
            // add to correct menu.
            std::string path; // Only used as index to map of submenus.
            auto top_menu = filters_menu;
            if (!entry.is_filter) {
                top_menu = effects_menu;
                path = "Effects";
            } else {
                path = "Filters";
            }

            if (!top_menu) { // It's possible that the menu doesn't exist (Kids' Inkscape?)
                std::cerr << "build_menu(): menu doesn't exist!" << std::endl; // Warn for now.
                continue;
            }

            auto current_menu = top_menu;
            for (auto const &submenu_name : submenu_name_list) {
                path.reserve(path.size() + submenu_name.size() + 1);
                path.append(submenu_name).append(1, '-');

                auto &submenu = submenus[path];

                if (!submenu) {
                    submenu = Gio::Menu::create();
                    current_menu->append_submenu(submenu_name, submenu);
                }

                current_menu = submenu;
            }
            current_menu->append(entry.effect_name, "app." + entry.effect_id);
        }
    }

    // Recent file
    auto const recent_menu = builder->get_object<Gio::Menu>("recent-files");

    auto rebuild_recent = [](Glib::RefPtr<Gio::Menu> const &submenu) {
        if (!submenu) {
            g_warning("No recent submenu in menus.ui found.");
            return;
        }

        submenu->remove_all();

        int max_files = Inkscape::Preferences::get()->getInt("/options/maxrecentdocuments/value");
        if (max_files <= 0) {
            return;
        }

        auto recent_files = Inkscape::IO::getInkscapeRecentFiles(max_files);
        auto shortened_path_map = Inkscape::IO::getShortenedPathMap(recent_files);
        auto regex = Glib::Regex::create("_");

        int inserted_entries = 0;
        for (auto const &recent_file : recent_files) {
            // check if given was generated by inkscape

            // Escape underscores to prevent them from being interpreted as accelerator mnemonics
            Glib::ustring raw_name = shortened_path_map[recent_file->get_uri_display()]; // recent_file->get_short_name();
            auto escaped = regex->replace_literal(raw_name, 0, "__", Glib::Regex::MatchFlags::DEFAULT);
            auto item = Gio::MenuItem::create(std::move(escaped), "");
            auto target = Glib::Variant<Glib::ustring>::create(recent_file->get_uri_display());
            // note: setting action and target separately rather than using convenience menu method append
            // since some filename characters can result in invalid "direct action" string
            item->set_action_and_target(Glib::ustring("app.file-open-window"), target);
            submenu->append_item(item);

            inserted_entries++;
        }

        if (inserted_entries == 0) { // Create a placeholder with a non-existent action
            auto nothing2c = Gio::MenuItem::create(_("No items found"), "app.nop");
            submenu->append_item(nothing2c);
        }
    };

    rebuild_recent(recent_menu);

    // Remove all or some icons. Also create label to tooltip map.
    auto prefs = Inkscape::Preferences::get();
    auto use_icons = prefs->getInt("/theme/menuIcons", 0);
    rewrite_menu(menu, use_icons);

    app->gtk_app()->set_menubar(menu);

    // rebuild recent items submenu when the list changes
    auto recent_manager = Gtk::RecentManager::get_default();
    recent_manager->signal_changed().connect([=] { rebuild_recent(recent_menu); });
}

/*
 * Disable all or some menu icons.
 *
 * This is quite nasty:
 *
 * We must disable icons in the Gio::Menu as there is no way to pass
 * the needed information to the children of Gtk::PopoverMenu and no
 * way to set visibility via CSS.
 *
 * MenuItems are immutable and not copyable so you have to recreate them.
 */
void rewrite_menu(Glib::RefPtr<Gio::Menu> const &menu, int use_icons)
{
    auto app = InkscapeApplication::instance();
    auto& extra_data = app->get_action_extra_data();
    auto& label_to_tooltip_map = app->get_menu_label_to_tooltip_map();

    for (int i = 0; i < menu->get_n_items(); ++i) {
        Glib::ustring label;
        Glib::ustring action;
        Glib::ustring target;
        Glib::VariantBase icon;
        bool use_icon = false;

        std::unordered_map<Glib::ustring, Glib::VariantBase> attributes;

        for (auto attr = menu->iterate_item_attributes(i); attr->next(); ) {
            // Attributes we need to create MenuItem or set icon.
            if (attr->get_name() == "label") {
                // Convert label while preserving unicode translations
                label = Glib::VariantBase::cast_dynamic<Glib::Variant<std::string> >(attr->get_value()).get();
            } else if (attr->get_name() == "action") {
                action = attr->get_value().print();
                action.erase(0, 1);
                action.erase(action.size()-1, 1);
            } else if (attr->get_name() == "target") {
                target = attr->get_value().print();
            } else if (attr->get_name() == "icon") {
                icon = attr->get_value();
            } else if (attr->get_name() == "use-icon") {
                use_icon = true;
            } else {
                // All the remaining attributes.
                attributes[attr->get_name()] = attr->get_value();
            }
        }
        Glib::ustring detailed_action = action;
        if (!target.empty()) {
            detailed_action += "(" + target + ")";
        }

        auto tooltip = extra_data.get_tooltip_for_action(detailed_action);
        label_to_tooltip_map[label] = std::move(tooltip);

        // std::cout << "  " << std::setw(30) << detailed_action
        //           << "  label: " << std::setw(30) << label.c_str()
        //           << "  use_icon (.ui): " << std::setw(6) << use_icon
        //           << "  icon: " << (icon ? "yes" : "no ")
        //           << "  useIcons: " << (int)useIcons
        //           << "  use_icon.size(): " << use_icon.size()
        //           << "  tooltip: " << tooltip.c_str()
        //           << std::endl;

        auto menu_item = Gio::MenuItem::create(label, detailed_action);
        if (icon && !use_icon <= use_icons) {
            menu_item->set_attribute_value("icon", icon);
        }

        // Add remaining attributes
        for (auto const &[key, value] : attributes) {
            menu_item->set_attribute_value(key, value);
        }

        // Add submenus
        for (auto link = menu->iterate_item_links(i); link->next(); ) {
            auto submenu = std::dynamic_pointer_cast<Gio::Menu>(link->get_value());
            rewrite_menu(submenu, use_icons);
            if (link->get_name() == "submenu") {
                menu_item->set_submenu(submenu);
            } else if (link->get_name() == "section") {
                menu_item->set_section(submenu);
            } else {
                std::cerr << "rebuild_menu: Unknown link type: " << link->get_name().raw() << std::endl;
            }
        }

        menu->remove(i);
        menu->insert_item(i, menu_item);
    }
}

/*
  Local Variables:
  mode:c++
  c-file-style:"stroustrup"
  c-file-offsets:((innamespace . 0)(inline-open . 0)(case-label . +))
  indent-tabs-mode:nil
  fill-column:99
  End:
*/
// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:fileencoding=utf-8:textwidth=99 :
