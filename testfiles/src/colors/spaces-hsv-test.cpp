// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * Unit tests for the HSV color space
 *
 * Copyright (C) 2023 Authors
 *
 * Released under GNU GPL v2+, read the file 'COPYING' for more information.
 */

#include "spaces-testbase.h"

namespace {

using Space::Type::HSV;
using Space::Type::RGB;

// clang-format off
INSTANTIATE_TEST_SUITE_P(ColorsSpacesHsv, fromString, testing::Values(
    // Taken from the w3c hwb example chart
    _P(in, "hwb(0 20 20)",              { 0.0,   0.75,  0.8         }, 0xcc3333ff),
    _P(in, "hwb(30 20.0 20.0)",         { 0.083, 0.75,  0.8         }, 0xcc7f33ff),
    _P(in, "hwb(90 20 20)",             { 0.25,  0.75,  0.8         }, 0x80cc33ff),
    _P(in, "hwb(0 40 40)",              { 0.0,   0.333, 0.6         }, 0x996666ff),
    _P(in, "hwb(30deg 40 40)",          { 0.083, 0.333, 0.6         }, 0x997f66ff),
    _P(in, "hwb(0.25turn 40 40)",       { 0.25,  0.333, 0.6         }, 0x809966ff),
    _P(in, "hwb(0 60 60%)",             { 0.0,   0,     0.5         }, 0x808080ff),
    _P(in, "hwb(30 60% 60)",            { 0.083, 0,     0.5         }, 0x808080ff),
    _P(in, "   hwb(90 60 60)   ",       { 0.25,  0,     0.5         }, 0x808080ff),
    _P(in, "hwb(0 80 80)",              { 0.0,   0,     0.5         }, 0x808080ff),
    _P(in, "hwb(0 100 100 / 0.5)",      { 0.0,   0,     0.5,   0.5  }, 0x80808080)
));

INSTANTIATE_TEST_SUITE_P(ColorsSpacesHsv, badColorString, testing::Values(
    "hwb", "hwb(", "hwb(360,"
));

INSTANTIATE_TEST_SUITE_P(ColorsSpacesHsv, toString, testing::Values(
    _P(out, HSV, { 0.333, 0.2,   0.8         }, "hwb(119 64 20)"),
    _P(out, HSV, { 0.333, 0.8,   0.258       }, "hwb(119 5.16 74.2)"),
    _P(out, HSV, { 1.0,   0.5,   0.004       }, "hwb(360 0.2 99.6)"),
    _P(out, HSV, { 0,     1,     0.2,   0.8  }, "hwb(0 0 80 / 80%)"),
    _P(out, HSV, { 0,     1,     0.2,   0.8  }, "hwb(0 0 80)", false)
));

INSTANTIATE_TEST_SUITE_P(ColorsSpacesHsv, convertColorSpace, testing::Values(
    // 20 random tests generated by python3 colorsys.rgb_to_hsv()
    _P(inb, HSV, {0.132, 0.333, 0.633}, RGB, {0.633, 0.590, 0.422}),
    _P(inb, HSV, {0.590, 0.814, 0.225}, RGB, {0.042, 0.126, 0.225}),
    _P(inb, HSV, {0.351, 0.643, 0.888}, RGB, {0.317, 0.888, 0.379}),
    _P(inb, HSV, {0.160, 0.718, 0.993}, RGB, {0.993, 0.966, 0.280}),
    _P(inb, HSV, {0.565, 0.905, 0.411}, RGB, {0.039, 0.265, 0.411}),
    _P(inb, HSV, {0.264, 0.981, 0.860}, RGB, {0.368, 0.860, 0.016}),
    _P(inb, HSV, {0.883, 0.628, 0.817}, RGB, {0.817, 0.304, 0.664}),
    _P(inb, HSV, {0.183, 0.676, 0.788}, RGB, {0.737, 0.788, 0.256}),
    _P(inb, HSV, {0.685, 0.769, 0.830}, RGB, {0.263, 0.192, 0.830}),
    _P(inb, HSV, {0.691, 0.876, 0.976}, RGB, {0.248, 0.121, 0.976}),
    _P(inb, HSV, {0.843, 0.118, 0.803}, RGB, {0.803, 0.708, 0.797}),
    _P(inb, HSV, {0.393, 0.732, 0.885}, RGB, {0.237, 0.885, 0.467}),
    _P(inb, HSV, {0.923, 0.762, 0.654}, RGB, {0.654, 0.155, 0.385}),
    _P(inb, HSV, {0.940, 0.294, 0.387}, RGB, {0.387, 0.273, 0.315}),
    _P(inb, HSV, {0.707, 0.348, 0.989}, RGB, {0.728, 0.645, 0.989}),
    _P(inb, HSV, {0.043, 0.541, 0.907}, RGB, {0.907, 0.542, 0.416}),
    _P(inb, HSV, {0.322, 0.639, 0.043}, RGB, {0.017, 0.043, 0.016}, false),
    // XXX GOT {0.327, 0.628, 0.043} in inverse (RGB to HSV)
    _P(inb, HSV, {0.035, 0.991, 0.422}, RGB, {0.422, 0.092, 0.004}),
    _P(inb, HSV, {0.871, 0.910, 0.735}, RGB, {0.735, 0.066, 0.583}),
    _P(inb, HSV, {0.625, 0.931, 0.824}, RGB, {0.057, 0.250, 0.824}),

    // No conversion
    _P(inb, HSV, {1.000, 0.400, 0.200}, HSV, {1.000, 0.400, 0.200})
));

INSTANTIATE_TEST_SUITE_P(ColorsSpacesHsv, normalize, testing::Values(
    // Note HSV is special in that it's hue component is radial so -0.2 == +0.8
    _P(inb, HSV, { 0.5,   0.5,   0.5,   0.5  }, HSV, { 0.5,   0.5,   0.5,   0.5  }),
    _P(inb, HSV, { 1.2,   1.2,   1.2,   1.2  }, HSV, { 0.2,   1.0,   1.0,   1.0  }),
    _P(inb, HSV, {-0.2,  -0.2,  -0.2,  -0.2  }, HSV, { 0.8,   0.0,   0.0,   0.0  }),
    _P(inb, HSV, { 0.0,   0.0,   0.0,   0.0  }, HSV, { 0.0,   0.0,   0.0,   0.0  }),
    _P(inb, HSV, { 1.0,   1.0,   1.0,   1.0  }, HSV, { 1.0,   1.0,   1.0,   1.0  })
));
// clang-format on

TEST(ColorsSpacesHsv, randomConversion)
{
    EXPECT_TRUE(RandomPassthrough(HSV, RGB, 1000));
}

TEST(ColorsSpacesHsv, components)
{
    auto c = Manager::get().find(HSV)->getComponents();
    ASSERT_EQ(c.size(), 3);
    ASSERT_EQ(c[0].id, "h");
    ASSERT_EQ(c[1].id, "s");
    ASSERT_EQ(c[2].id, "v");
    ASSERT_EQ(c[0].index, 0);
    ASSERT_EQ(c[1].index, 1);
    ASSERT_EQ(c[2].index, 2);
}

} // namespace

/*
  Local Variables:
  mode:c++
  c-file-style:"stroustrup"
  c-file-offsets:((innamespace . 0)(inline-open . 0))
  indent-tabs-mode:nil
  fill-column:99
  End:
*/
// vim: expandtab:shiftwidth=4:tabstop=8:softtabstop=4 :
